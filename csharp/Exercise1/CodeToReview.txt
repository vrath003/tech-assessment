using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Review
{
    public class People
    {
        private static readonly DateTimeOffset Under16 = DateTimeOffset.UtcNow.AddYears(-15);  //Under16 variable is declared once and it is readonly by all instances of class 
        public string Name { get; private set; }
        public DateTimeOffset DOB { get; private set; }

        public People(string name) : this(name, Under16.Date) { }

       /******************************************************************
       DOB variable is declared as DateTimeOffset type above(line 13) but passed as DateTime type below(line 20). 
       This creates inconsistency and there is a chance of loosing timezone offset.
       *********************************************************************/

        public People(string name, DateTime dob)
        {
            Name = name;
            DOB = dob;
        }
    }

    public class BirthingUnit
    {
        /// <summary>
        /// MaxItemsToRetrieve
        /// </summary>
        private List<People> _people;

        public BirthingUnit() {
            _people = new List<People>();
        }

        /// <summary>
        /// GetPeoples
        /// </summary>
        /// <param name="j"></param>  /* Correction: This comment is misleading. It should be param name="i" instead of param name="j" */
        /// <returns>List<object></returns>

        /*  Above commenting could have been done in a tidy way as below.
        Below function returns a list of people objects with name either Bob or Betty and age 18 to 84 years young.  */

        public List<People> GetPeople(int i)  
        {
            for (int j = 0; j < i; j++) {
                try
                {
                    // Creates a dandon Name  

                    /*Correction in comment above: work should be "random"  instead of "dandon" */

                    string name = string.Empty;

                    /* random variable below is re created whenever the loop runs. This should be outside the loop. */

                    var random = new Random();

                    /*Correction: In below line random.Next(0,1) will always return 0 therefore it can be corrected to random.Next(0, 2) instead of random.Next(0, 1)*/

                    if (random.Next(0, 1) == 0) {  
                        name = "Bob";
                    }
                    else { name = "Betty"; }

                    // Adds new people to the list
                    /* Below code is trying to add a random name to list of people and random age between 18 and 85. But it looks instead of 356 it must be 365 which is still 
                    not accurate since a year have 365.25 days, therefore in below leap year is not taken into account. Since first parameter of Timespan is days which is tried to convert into years by multiplying the random number generated by random.Next(18,85) with 356. However
                    it must be 365 days to make it a year. Therefore it looks like a typo mistake in the line below. However it will not handle leap year as well since a year
                    have 365.25 days. There is a function AddYears() which can be used here to substract years as well. With the usage of AddYears the below line becomes
                    var age = random.Next(18,85);
                    _people.Add(new People(name, DateTime.UtcNow.AddYears(-age))); */

                    _people.Add(new People(name, DateTime.UtcNow.Subtract(new TimeSpan(random.Next(18, 85) * 356, 0, 0, 0))));
                }
                catch (Exception e)
                {
                    // Dont think this should ever happen    --> We should refrain with this kind of over confident commenting since there could be enumerous exceptions that could happen.It is not idealistic to test for each exception.
                    /* Below exception is very generic and static in nature. As best practise exceptions should be caught and displayed as they happen. */
                    /* Something of this sort should be better throw new Exception("Failed to create user. Exception trace is \n",e); */
                    throw new Exception("Something failed in user creation");
                }
            }
            return _people;
        }
        
        private IEnumerable<People> GetBobs(bool olderThan30) {
            /* It looks like in the below line of code it should be 365 instead of 356 to make it multiple of years. However it is still not accurate since leap year is not
            taken into account be below code logic and offset is not taken into account as well.  More accurate code would be DateTimeOffset.UtcNow.AddYears(-30) */
            return olderThan30 ? _people.Where(x => x.Name == "Bob" && x.DOB >= DateTime.Now.Subtract(new TimeSpan(30 * 356, 0, 0, 0))) : _people.Where(x => x.Name == "Bob");
        }
        
        /* Method to return name of people with certain criteria lastName string in it */
        public string GetMarried(People p, string lastName)
        {
            if (lastName.Contains("test"))
                return p.Name;
            if ((p.Name.Length + lastName).Length > 255) {  //String (lastName) and number(p.Name.Length) cannot be concatenated.
                (p.Name + " " + lastName).Substring(0, 255);   //Nothing is returned here after this line for this condition. It is unused condition.
            }

            return p.Name + " " + lastName;
        }
    }
}

/***********************Reflection********************************/

/***********************Code Smells********************************/

/*

1. Bloaters - Long Parameter List 
It do not fit accurately but I think instead of using Substract method which have 4 parameters we could have used AddYears method with a 
parameter. It makes code readable.

2. Dispensables - Comments

Method and class names could be more meaningful like below.

People  --> Person

BirthingUnit --> PersonGenerator

GetPeople --> GeneratePeople

GetBobs --> GetPeopleNamedBob

GetMarried --> GenerateFullName

*/